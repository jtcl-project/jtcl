/*
 * EventAdaptor.java --
 *
 *	Base class for event adaptors classes generated by Tcl.
 *
 * Copyright (c) 1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 * RCS: @(#) $Id: EventAdaptor.java,v 1.3 2002/12/21 04:04:04 mdejong Exp $
 */

package tcl.pkg.java;

import java.beans.EventSetDescriptor;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Hashtable;

import tcl.lang.Interp;
import tcl.lang.TCL;
import tcl.lang.TclBoolean;
import tcl.lang.TclDouble;
import tcl.lang.TclException;
import tcl.lang.TclInteger;
import tcl.lang.TclList;
import tcl.lang.TclObject;
import tcl.lang.TclRuntimeError;
import tcl.lang.TclString;

/*
 * This class is the base class for all event adaptors used by Tcl.
 * It handles events generated by Java code and passes them to the Tcl
 * interpreter.
 *
 * A subclass of EventAdaptor will implement a particular event interface
 * and is usually generated on-the-fly by the AdaptorGen class.
 *
 * NOTE:
 *
 *    + THIS CLASS MUST BE PUBLIC, otherwise some JVM may refuse to load
 *      subclasses of this class in the custom AdaptorClassLoader.
 *
 *    + Some methods in this class are called by subclasses and thus must
 *      be public. All public methods are prefixed with "_" in order to
 *	avoid conflicts with method names in event interfaces. These methods
 *	are also declared "final", so that if a conflict does happen, it
 *	will be reported by the JVM as an attempt to redefine a final
 *	methood.
 */

public class EventAdaptor {

	// true if the init() has been called, false otherwise.

	private boolean initialized;

	// The event should be fired to this interpreter.

	Interp interp;

	// The event source object.

	Object source;

	// Stores the callbacks that are currently being handled by the target.

	Hashtable callbacks;

	// If an Exception is throws during the execution of the event
	// handler, it is stored in this member variable for later processing
	// by _wrongException(). If no Exception is thrown, the value of this
	// variable is null.

	Throwable exception;

	// The event set handled by this adaptor.

	EventSetDescriptor eventDesc;

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * EventAdaptor --
	 * 
	 * Creates a new EventAdaptor instance.
	 * 
	 * Side effects: Member fields are initialized.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public EventAdaptor() {
		initialized = false;
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * init --
	 * 
	 * Initialize the event adaptor object and register it as a listener to the
	 * event source.
	 * 
	 * The initialization is carried out in this method instead of the
	 * constructor. This makes it easy to generate class data for the event
	 * adaptor subclasses.
	 * 
	 * Results: None.
	 * 
	 * Side effects: The adaptor is registered as a listener to the event
	 * source.
	 * 
	 * ----------------------------------------------------------------------
	 */

	void init(Interp i, // Interpreter in which the event should fire.
			Object src, // Event source.
			EventSetDescriptor desc) // Describes the event to listen to.
			throws TclException // Standard Tcl exception.
	{
		interp = i;
		callbacks = new Hashtable();
		eventDesc = desc;
		source = src;

		Method method = eventDesc.getAddListenerMethod();
		if (method != null) {
			Object args[] = new Object[1];
			args[0] = this;

			try {
				method.invoke(source, args);
			} catch (Exception e) {
				throw new ReflectException(i, e);
			}
		}
		initialized = true;
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * setCallback --
	 * 
	 * Set the callback script of the given event.
	 * 
	 * Results: None.
	 * 
	 * Side effects: If a callback has already been installed for the given
	 * event, it will be replaced by the new callback.
	 * 
	 * ----------------------------------------------------------------------
	 */

	void setCallback(String eventName, // Name of the event for which a callback
			// should be created.
			TclObject command) // Tcl command to invoke when the given event
	// fires.
	{
		check();
		TclObject oldCmd = (TclObject) callbacks.get(eventName);
		if (oldCmd != null) {
			callbacks.remove(eventName);
		}
		// We use to preserve the passed in TclObject, but that leads
		// to a memory leak in Tcl Blend because release was not called.
		// Instead just use a TclString which is managed by Java.
		TclObject str = TclString.newInstance(command.toString());
		callbacks.put(eventName, str);
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * deleteCallback --
	 * 
	 * Deletes the callback script of the given event, if one exists.
	 * 
	 * Results: The number of events that are still handled after deleting the
	 * script for the given event.
	 * 
	 * Side effects: If no events are handled after deleting the script for the
	 * given event, this event listener is removed from the object and the
	 * adaptor is uninitialized.
	 * 
	 * ----------------------------------------------------------------------
	 */

	int deleteCallback(String eventName) // Name of the event for which a
			// callback
			// should be created.
			throws TclException // Standard Tcl exception.
	{
		check();

		TclObject oldCmd = (TclObject) callbacks.get(eventName);
		if (oldCmd != null) {
			callbacks.remove(eventName);
		}

		int size = callbacks.size();

		if (size == 0) {
			try {
				Method method = eventDesc.getRemoveListenerMethod();
				if (method != null) {
					Object args[] = new Object[1];
					args[0] = this;

					method.invoke(source, args);
				}
			} catch (Exception e) {
				throw new ReflectException(interp, e);
			} finally {
				initialized = false;
				callbacks = null;
				eventDesc = null;
				interp = null;
				source = null;
			}
		}

		return size;
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * getCallback --
	 * 
	 * Query the callback command for the given event.
	 * 
	 * Results: The callback command for the given event, if any, or null if no
	 * callback was registered for the event.
	 * 
	 * Side effects: None.
	 * 
	 * ----------------------------------------------------------------------
	 */

	TclObject getCallback(String eventName) // Name of the event to query.
	{
		check();
		return (TclObject) callbacks.get(eventName);
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * getHandledEvents --
	 * 
	 * Query all the events that are currently handled by this adaptor.
	 * 
	 * Results: None.
	 * 
	 * Side effects: The full names of the handled events are appended to the
	 * list.
	 * 
	 * ----------------------------------------------------------------------
	 */

	void getHandledEvents(TclObject list) // TclList to store the name of the
	// handled
	// events.
	{
		check();
		try {
			String interfaceName = eventDesc.getListenerType().getName();

			for (Enumeration e = callbacks.keys(); e.hasMoreElements();) {
				String eventName = (String) e.nextElement();
				TclList.append(null, list, TclString.newInstance(interfaceName
						+ "." + eventName));
			}
		} catch (TclException e) {
			throw new TclRuntimeError("unexpected TclException: " + e);
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * processEvent --
	 * 
	 * This method is called whenever an event is fired by the event source. If
	 * a callback has been registered, the Tcl command is executed.
	 * 
	 * Results: None.
	 * 
	 * Side effects: The callback script may have any side effect.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final void _processEvent(Object params[], // Event object associated
			// with this event.
			String eventName) // Name of the event.
			throws Throwable {
		check();
		exception = null;

		TclObject cmd = (TclObject) callbacks.get(eventName);
		if (cmd != null) {
			Class paramTypes[] = null;
			Method methods[] = eventDesc.getListenerType().getMethods();
			for (int i = 0; i < methods.length; i++) {
				if (methods[i].getName().equals(eventName)) {
					paramTypes = methods[i].getParameterTypes();
					break;
				}
			}

			BeanEvent evt = new BeanEvent(interp, paramTypes, params, cmd);
			interp.getNotifier().queueEvent(evt, TCL.QUEUE_TAIL);
			evt.sync();

			exception = evt.exception;
			if (exception != null) {
				throw exception;
			}
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * check --
	 * 
	 * Sanity check. Make sure the init() method has been called on this object.
	 * 
	 * Results: None.
	 * 
	 * Side effects: TclRuntimeError is thrown if the init() method has not been
	 * caled.
	 * 
	 * ----------------------------------------------------------------------
	 */

	private final void check() {
		if (!initialized) {
			throw new TclRuntimeError("EventAdaptor not initialized");
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _wrongException --
	 * 
	 * This procedure is called if the binding script generates an exception
	 * which is not declared in the method's "throws" clause. If the exception
	 * is an unchecked exception (i.e., a subclass of java.lang.Error), it gets
	 * re-thrown. Otherwise, a Tcl bgerror is triggered and this procedure
	 * returns normally.
	 * 
	 * Results: None.
	 * 
	 * Side effects: unchecked exceptions will be re-thrown.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final void _wrongException() throws Error, // If a Error was caught
			// during the
			// execution of the binding script, it
			// is re-thrown.
			RuntimeException // If a RuntimeException was caught during the
	// execution of the binding script, it
	// is re-thrown.
	{
		if (exception instanceof Error) {
			throw (Error) exception;
		}
		if (exception instanceof RuntimeException) {
			throw (RuntimeException) exception;
		}

		if (!(exception instanceof TclException)) {
			interp.setResult("unexpected exception: " + exception);
		} else {
			// The error message is already in the interp in the case of
			// a TclException, so there is no need to set it here.
		}

		interp.addErrorInfo("\n    (command bound to event)");
		interp.backgroundError();
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_boolean --
	 * 
	 * Converts the interp's result to a boolean value and returns it.
	 * 
	 * Results: A boolean value from the interp's result; false if the
	 * conversion fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final boolean _return_boolean() {
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return false;
		}

		TclObject result = interp.getResult();
		try {
			return TclBoolean.get(interp, result);
		} catch (TclException e) {
			interp
					.addErrorInfo("\n    (attempting to return boolean from binding)");
			interp.backgroundError();
			return false;
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_byte --
	 * 
	 * Converts the interp's result to a byte value and returns it.
	 * 
	 * Results: A byte value from the interp's result; 0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final byte _return_byte() {
		return (byte) _return_int();
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_char --
	 * 
	 * Converts the interp's result to a char value and returns it.
	 * 
	 * Results: A char value from the interp's result; \0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final char _return_char() {
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return '\0';
		}

		String s = interp.getResult().toString();

		if (s.length() == 1) {
			return s.charAt(0);
		} else {
			interp.setResult("expecting character but got \"" + s + "\"");
			interp
					.addErrorInfo("\n    (attempting to return character from binding)");
			interp.backgroundError();
			return '\0';
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_double --
	 * 
	 * Converts the interp's result to a double value and returns it.
	 * 
	 * Results: A double value from the interp's result; 0.0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final double _return_double() {
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return 0.0;
		}

		TclObject result = interp.getResult();
		try {
			return TclDouble.get(interp, result);
		} catch (TclException e) {
			interp
					.addErrorInfo("\n    (attempting to return floating-point number from binding)");
			interp.backgroundError();
			return 0.0;
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_float --
	 * 
	 * Converts the interp's result to a float value and returns it.
	 * 
	 * Results: A float value from the interp's result; 0.0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final float _return_float() {
		return (float) _return_double();
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_int --
	 * 
	 * Converts the interp's result to a int value and returns it.
	 * 
	 * Results: A int value from the interp's result; 0 if the conversion fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final int _return_int() {
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return 0;
		}
		TclObject result = interp.getResult();
		try {
			return TclInteger.getInt(interp, result);
		} catch (TclException e) {
			interp
					.addErrorInfo("\n    (attempting to return integer number from binding)");
			interp.backgroundError();
			return 0;
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_long --
	 * 
	 * Converts the interp's result to a long value and returns it.
	 * 
	 * Results: A long value from the interp's result; 0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final long _return_long() {
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return 0;
		}
		TclObject result = interp.getResult();
		try {
			return TclInteger.getLong(interp, result);
		} catch (TclException e) {
			interp
					.addErrorInfo("\n    (attempting to return long number from binding)");
			interp.backgroundError();
			return 0;
		}
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_short --
	 * 
	 * Converts the interp's result to a short value and returns it.
	 * 
	 * Results: A short value from the interp's result; 0 if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final short _return_short() {
		return (short) _return_int();
	}

	/*
	 * ----------------------------------------------------------------------
	 * 
	 * _return_Object --
	 * 
	 * Converts the interp's result to an instance of the given class and
	 * returns it.
	 * 
	 * Results: A Object value from the interp's result; null if the conversion
	 * fails.
	 * 
	 * Side effects: A background error is reported if the conversion fails.
	 * 
	 * ----------------------------------------------------------------------
	 */

	public final Object _return_Object(String className) // The name of the
	// class that the
	// object must
	// belong to.
	{
		if (exception != null) {
			// An unexpected exception had happen during the execution of
			// the binding. We return an "undefined" value without looking
			// at interp.getResult().

			return null;
		}

		if (className.equals("java.lang.String")) {
			return interp.getResult().toString();
		}

		Class cls = null;
		try {
			cls = Class.forName(className);
		} catch (ClassNotFoundException e) {
			// This exception should never happen here because the class
			// of the given name should have already been referenced
			// before execution comes to here (e.g, when a parameter of
			// this class is passed to the method).
			//
			// If the exception indeed happens, our byte-code generator
			// AdaptorGen must be at fault.

			throw new TclRuntimeError("unexpected exception " + e);
		}

		try {
			TclObject result = interp.getResult();
			Object obj = ReflectObject.get(interp, result);
			if (!cls.isInstance(obj)) {
				throw new TclException(interp, "cannot cast object "
						+ result.toString() + " (" + obj.toString()
						+ ") to required type " + className);
			}
			return obj;
		} catch (TclException e) {
			interp
					.addErrorInfo("\n    (attempting to return object from binding)");
			interp.backgroundError();
			return null;
		}
	}

} // end EventAdaptor

